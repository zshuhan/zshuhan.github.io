<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>(✿◡‿◡)胖涵</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zshuhan.github.io/"/>
  <updated>2020-05-11T07:36:49.176Z</updated>
  <id>https://zshuhan.github.io/</id>
  
  <author>
    <name>舍予</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络学习笔记（三）之传输层</title>
    <link href="https://zshuhan.github.io/2020/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://zshuhan.github.io/2020/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2020-05-11T04:35:35.959Z</published>
    <updated>2020-05-11T07:36:49.176Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="计算机网络学习笔记三之传输层"><a class="markdownIt-Anchor" href="#计算机网络学习笔记三之传输层"></a> 计算机网络学习笔记（三）之传输层</h2><h3 id="思维导图"><a class="markdownIt-Anchor" href="#思维导图"></a> 思维导图</h3><p><img src="/" class="lazyload" data-src="G:%5Cbaidudownload%5C%E4%BC%A0%E8%BE%93%E5%B1%82.png"  alt="传输层" /></p><h3 id="传输层协议的概述"><a class="markdownIt-Anchor" href="#传输层协议的概述"></a> 传输层协议的概述</h3><h4 id="进程之间的通信"><a class="markdownIt-Anchor" href="#进程之间的通信"></a> 进程之间的通信</h4><ul><li>运输层：为<u>应用程序</u>之间提供<u>端到端</u>的逻辑通信</li><li>网络层：提供<u>主机</u>之间的逻辑通信</li></ul><p>传输层的功能：分用和复用</p><p>传输层所需的协议：面对连接的TCP和无连接的UDP</p><p>网络层 VS. 传输层</p><img src="/"  lazyloadclass="" data-src="/2020/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/image-20200511122242787.png"><h3 id="udp协议"><a class="markdownIt-Anchor" href="#udp协议"></a> UDP协议</h3><h4 id="udp概述"><a class="markdownIt-Anchor" href="#udp概述"></a> UDP概述</h4><ol><li><p>概念</p><p>用户数据报协议（UDP）：在IP 的数据报服务之上增加了<strong>复用</strong>和<strong>分用</strong>的功能及<strong>差错检测</strong>的功能</p></li><li><p>UDP的主要特点</p><ul><li>UDP是<strong>无连接</strong>的，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延</li><li>UDP 使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表</li><li>UDP<strong>是面向报文的</strong>。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP一次交付一个完整的报文</li><li>UDP <strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求</li><li>UDP 支持<strong>一对一、一对多、多对一和多对多的交互通信</strong></li><li>UDP 的<strong>首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短</li></ul></li></ol><h4 id="udp的首部格式"><a class="markdownIt-Anchor" href="#udp的首部格式"></a> UDP的首部格式</h4><p>​UDP数据报包含两个部分：UDP首部和用户数据</p><p>​UDP首部有8个字节，由4个字段组成，每个字段的长度都是两个字节</p><p>首部格式：</p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511124651666.png"  alt="image-20200511124651666" /></p><ul><li>源端口：源端口号，在需要对方回信时选用，不需要时可选用0</li><li>目的端口：目的端口号，在终点交付报文时必须要使用</li><li>长度：UDP用户数据报的长度，其最小值是8（仅有首部）</li><li>检验和：检测UDP用户数据报在传输中是否有错，有错就丢弃</li></ul><h3 id="tcp协议"><a class="markdownIt-Anchor" href="#tcp协议"></a> TCP协议</h3><h4 id="tcp协议的特点"><a class="markdownIt-Anchor" href="#tcp协议的特点"></a> TCP协议的特点</h4><ul><li><strong>面向连接</strong></li><li>每一条 TCP 连接只能<strong>有两个端点 <strong>，每一条 TCP 连接只能是</strong>点对点</strong>的（一对一）</li><li>提供<strong>可靠交付的服务</strong></li><li>提供<strong>全双工</strong>通信</li><li><strong>面向字节流</strong></li></ul><h4 id="tcp报文段"><a class="markdownIt-Anchor" href="#tcp报文段"></a> TCP报文段</h4><p>TCP报文段用于运载数据，建立连接，释放连接和应答。</p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511130912574.png"  alt="image-20200511130912574" /></p><p>各字段意义：</p><ul><li>源端口和目的端口：各占 2字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li><li>序号：占4字节。 TCP是面向字节流的(就是说TCP传送时是按照一个一个字节来传送的)，所以TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>)确认：占4 字节，是期望收到对方的下一个报文段的数据的第一个字 节的序号。若确认号为N，则表示已正确收到序号N-1的报文。</li><li>数据偏移(即首部长度)：占4 位，这里不是IP数据报分片的那个数据偏移，而是表示首部长度，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。</li><li>保留：占6位， 保留为今后使用，但目前应置为0,该字段可以忽略不计。</li><li>紧急位URG：当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。但是URG需要和紧急指针配套使用，也就是说数据从第-一个字节到紧急指针所指字节就是紧急数据。</li><li>确认位ACK：只有当ACK=1时确认号字段才有效。当ACK=0时,确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li><li>推送位PSH(Push) ：接收TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li><li>复位位RST (Reset) ：当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他因)，必须释放连接，然后再重新建立运输连接。</li><li>同步位SYN：同步 SYN=I表示这是一一个连接请求或连接接收报文。当SYN=I, ACK=0时，表明这是一一个连接请求报文，对方若同意建立连接，则在响应报文中使用SYN=I, ACK=1。即SYN=1 就表示这是一一个连接请求或连接接收报文。</li><li>终止位FIN (Finish)：用来释放-一个连接。 FIN=1 表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。</li><li>窗口：占2 字节。它指出了现在允许对方发送的数据量，接收方的数据缓存空间是有限的，故用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节。</li><li>)检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，和UDP一样，要在TCP报文段的前面加上12字节的伪首部(只需将UDP伪首部的第4个字段，即协议字段的17改成6,其他的和UDP一样)。</li><li>紧急指针：占16 位，指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)。</li><li>选项：长度可变。TCP最初只规定了一种选项，即最大报文段长度(MaximumSegmen tSize,MSS)。 MSS是TCP报文段中的数据字段的最大长度。</li><li>填充：这是为了 使整个首部长度是4字节的整数倍。</li></ul><h4 id="tcp连接管理"><a class="markdownIt-Anchor" href="#tcp连接管理"></a> TCP连接管理</h4><p>TCP是面向连接的协议。因此每一个TCP连接都有三个阶段:连接建立、数据传送和连接释放。   TCP连接的管理就是使运输连接的建立和释放都能正常进行。</p><p>在TCP连接建立的过程中要解决以下三个问题:</p><ol><li>要使每- -方都能够确知对方的存在。</li><li>要允许双方协商一些参数(如最大窗口值、是否使用窗口扩大选项、时间戳选项以及服务质量等)。</li><li>能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配。</li></ol><p>TCP把连接作为最基本的抽象，每- -条TCP连接有两个端点，TCP连接的端点不是主机,不是主机的IP地址,不是应用进程，也不是传输层的协议端口.TCP连接的端口叫做套接字( socket)或插口。端口拼接到IP地址即构成了套接字。<br />每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定。<br />TCP连接的建立采用客户/服务器方式。主动发起连接建立的应用进程叫做客户机(Client), 而<br />被动等待连接建立的应用进程叫做服务器(Server)。</p><h5 id="tcp的连接建立三次握手"><a class="markdownIt-Anchor" href="#tcp的连接建立三次握手"></a> TCP的连接建立（三次握手）</h5><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511133218813.png"  alt="image-20200511133218813" /></p><p>步骤：</p><ol><li>客户机的TCP首先向服务器的TCP发送一个连接请求报文段，设置初始序号，SYN=1,序号=X</li><li>服务器的TCP收到连接请求报文段后，同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1,并且服务器随机产生起始序号seq=y</li><li>客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置1,序号字段为x+1,确认号字段ack=y+1</li></ol><h5 id="tcp的连接释放四次握手"><a class="markdownIt-Anchor" href="#tcp的连接释放四次握手"></a> TCP的连接释放（四次握手）</h5><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511133949759.png"  alt="image-20200511133949759" /></p><p>步骤：</p><ol><li>客户机打算关闭连接，就向其TCP发送一个连接释放报文段，并停止再发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1, seq=u</li><li>服务器收到连接释放报文段后即发出确认，确认号是ack=u+1,而这个报文段自己的序号是v,等于它前面已传送过的数据的最后一个字节的序号加1. 此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。</li><li>若服务器已经没有要向客户机发送的数据,就通知TCP释放连接，此时其发出FIN=1的连接释放报文段。</li><li>客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1，确认号ack=w+1,序号seq=u+1.此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入到连接关闭状态。</li></ol><h5 id="对连接释放的总结"><a class="markdownIt-Anchor" href="#对连接释放的总结"></a> 对连接释放的总结：</h5><p>(1)连接建立<br />分为3步:<br />①SYN=1，seq=x.<br />②SYN=1，ACK=1, seq=y, ack=x+1.<br />③ACK=1，seq=x+1, ack= y+1.<br />(2)释放连接<br />分为4步:<br />①FIN=1, seq=u。<br />②ACK=1, seq=v, ack=u+1.<br />③FIN=1, ACK=1，seq=w， ack=u+1。<br />④ACK=1, seq=u+1, ack-=w+1.</p><h4 id="tcp可靠传输"><a class="markdownIt-Anchor" href="#tcp可靠传输"></a> TCP可靠传输</h4><p>TCP使用了校验、序号、确认和重传等机制来实现可靠传输</p><ol><li>校验：和UDP一样的校验机制</li><li>序号：TCP首部的序号字段用来保证数据能有序提交给应用层</li><li>确认：首部的确认号是期望下次收到的报文的序号。使用累计确认。</li><li>重传：有两种事件会导致TCP对报文段进行重传:超时和冗余ACK。<ul><li>超时：TCP每发送一一个报文段，就对这个报文段设置一次计时器。 只要计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。</li><li>冗余ACK：超时触发重传存在的一个问题就是超时周期往往太长，发送方可通过冗余ACK检测丢包情况。</li></ul></li></ol><h4 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h4><p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。利用<strong>滑动窗口协议</strong>的机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>接收方根据自己接收缓存大小,动态更新发送方窗口,即窗口字段。表示接收方能接收的最大字节数。发送方根据窗口字段限制自己发送窗口大小。发送窗口实际大小取拥塞窗口中的最小值。</p><h4 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h4><ol><li><p>拥塞：在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞。</p><p>拥塞出现的原因：∑对资源需求&gt;可用资源</p></li><li><p>拥塞控制：防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</p><ul><li><p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p></li><li><p>拥塞控制是一 个全局性的过程，涉及到所有的<br />主机、所有的路由器，以及与降低网络传输性<br />能有关的所有因素。</p></li></ul></li><li><p>拥塞控制与流量控制的区别</p><p>​拥塞控制是-一个全局性的过程。但TCP连接的端点只要迟迟不能收到对方的确认信息，就猜想在当前网络中的某处很可能发生了拥塞，但这时却无法知道拥塞到底发生在网络的何处，也无法知道发生拥塞的具体原因。相反，流量控制往往指点对点通信量的控制，是个端到端的问题(接收端控制发送端)。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p></li><li><p>进行拥塞控制需付出的代价</p><ul><li>首先需要获得网络内部流量分布的信息。</li><li>在实施拥塞控制时，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外开销。</li><li>拥塞控制有时需要将一些资源(如缓存、带宽等)分配给个别用户单独使用，这样就使得网络资源不能更好地实现共享。</li></ul></li><li><p>几种拥塞控制的方法</p><p>（1）慢开始</p><p>​开始发送时令拥窒窗口=1.每收到一个对新的报文的确认就让窗口+1。窗口大小成指数增长,达到上限(阀值)后使用拥塞避免算法</p><p>​</p><p>（2）拥塞避免</p><p>​拥塞窗口每经过一个RTT后+1 ,而不是加倍,变成线性增长。当出现拥塞时，令阀值=当前窗口/2然后设置拥塞窗口=1，再次用慢开始。当窗口&lt;阀值时.使用慢增长。当拥塞窗口&gt;阀值时，改用拥塞避免</p><p>(3) 快重传</p><p>​可靠传输中的冗余ACK可用于拥塞检测。检测到冗余ACK时直接快速重传</p><p>（4）快恢复</p><p>​ 当发送端收到连续个冗余ACK后,就把阀值=当前窗口/2。与慢开始不同的是不是把拥塞窗口=1 ,而是将拥塞窗口=当前窗口/2，然后用拥塞避免算法,因而是快恢复</p></li></ol><h3 id="传输层习题"><a class="markdownIt-Anchor" href="#传输层习题"></a> 传输层习题</h3><ol><li><p>主机甲和主机乙已建立了TCP连接，甲始终以MSS=1KB大小的段发送数据，并一直有数据发送;乙每收到一个数据段都会发出一个接收窗口为10KB的确认段。若甲在t时刻发生超时时拥塞窗口为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口是(  )。<br />A.10KB B.12KBC.14KB D.15KB</p><p>【答案】A</p><p>【解析】当t时刻发生超时时，把shresh设为8的一半，即为4,且拥塞窗口设为1KB.然后经历10个RTT后，拥塞窗口的大小依次为2、4、 5.6、7、8、9、10、 11. 12, 而发送窗口取当时的拥塞窗口和接收窗口的最小值，而接收窗口始终为10KB,所以此时的发送窗口为10KB,选A.<br />实际上该题接收窗口一直为10KB,可知不管何时，发送窗口一定小于等于10KB, 选项中只有A选项满足条件，可直接得出选A.</p></li><li><p>(  )字段包含在TCP首部中，而不包含在UDP首部中。<br />A.目的端口号<br />B.序列号<br />C.校验和<br />D.目的IP地址</p><p>【答案】B</p><p>【解析】TCP报文段和UDP数据报都包含源端口、目的端口、校验号。由于UDP提供不可靠的传输服务，不需要对报文编号，因此不会有序列号字段，而TCP提供可靠的传输服务，因此需要设置序列号字段。而目的IP地址属于IP数据报中的内容。</p></li><li><p>一个TCP连接的数据传输阶段，如果发送端的发送窗口值由2000变为3000,意味着发送端可以(  ）。<br />A.在收到一个确认之前可以发送3000个TCP报文段<br />B.在收到一个确认之前可以发送1000字节<br />C.在收到一个确认之前可以发送3000字节<br />D.在收到一个确认之前可以发送2000个TCP报文段</p><p>【答案】C</p><p>【解析】TCP提供的是可靠的字节流传输服务，使用窗口机制进行流量控制与拥塞控制。TCP的滑动窗口机制是面向字节的，因此窗口大小的单位为字节。假设发送窗口的大小为N,这意味着发送端可以在没有收到确认的情况下连续发送N个字节。</p></li><li><p>主机甲与主机乙之间已建立一个TCP连接，主机甲向主机乙发送了两个连续的TCP段，分别包含300字节和500字节的有效载荷，第一个段的序列号为200，主机乙正确接收到这两个数据段后，发送给主机甲的确认序列号是( )。<br />A.500<br />B.700<br />C.800<br />D.1000</p><p>【答案】D</p><p>【解析】返回的确认序列号是接收方期待收到对方下一个报文段数据部分的第一-个字 节的序号，因此乙在正确接收到两个段后，返回给甲的确认序列号是200+300+500=1000.</p></li><li><p>主机甲向主机乙发送一个(SYN=I, seq-11220) 的TCP段，期望与主机乙建立TCP连接，若主机乙接受该连接请求，则主机乙向主机甲发送的正确的TCP段可能是( )。<br />A. (SYN=0, ACK=0，seq=11221， ack=11221 )<br />B. (SYN=1， ACK=I, seq=11220， ack-11220 )<br />C. (SYN=1, ACK=1，seq-11221， ack=11221 )<br />D. (SYN=0, ACK=0, seq=11220， ack-11220 )</p><p>【答案】C</p><p>【解析】在确认报文段中，同步位SYN和确认位ACK必须都是1;返回的确认号seq是甲发送的初始序号seq-11220 加1,即ack=11221; 同时乙也要选择并消耗一个初始序号seq, seq 值由乙的TCP进程任意给出，它与确认号、请求报文段的序号没有任何关系。</p></li><li><p>可靠的传输协议中的“可靠”指的是( )。<br />A.使用面向连接的会话<br />B.使用“尽力而为”的传输<br />C.使用滑动窗口来维持可靠性<br />D.使用确认机制来确保传输的数据不丢失<br />【答案】 D<br />【解析】如果-一个协议使用确认机制对传输的数据进行认，那么可以认为是一一个可靠的协议。如果-一个协议用“尽力而为”的传输方式，那么是不可靠的。例如，TCP 对传输的报文段提供确认，因此是可靠的传输协议;而UDP不提供确认，因此是不可靠的传输协议。</p></li><li><p>简述ICMP、 DHCP、 UDP和SMTP作用。<br />答: ICMP：:辅助IP协议正常工作，用以解决差错报告与控制的主要手段。<br />DHCP:集中管理、分配IP地址,便网络环境中的主机动态获得IP地址、DNS服务器地址等信息，并能提供地址的使用率。<br />UDP: 提供无连接、“尽最大努力交付”的教据报传输服务。<br />SMTP:向用户提供高效可靠的邮件传输。</p></li><li><p>在TCP中拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法?这里每一种算法各起什么作用?“乘法减小“和”加<br />法增大&quot;各用在什么情况下?</p><p>答:①慢开始:开始发送时，令拥塞窗口=1.，每收到一个对新的报文的确认后窗口十1。作用: 窗口大小成指数增长，可使分组注入到网络的速率更合理</p><p>②拥塞避免:拥塞离口每经过一个RTT后+1。当窗口&lt;阈值时，使用慢开始;当拥塞窗口&gt;阈值时,改用拥塞避免。作用:便拥塞窗口按线性增长,而不是加信。</p><p>③快重传:可靠传输中的ACK可用于拥塞检测，检测到冗余ACK时直接快速重传。作用:使网络的吞吐量提高</p><p>④快恢复:当发送端收到连续三个冗余ACk后,就把阈值=当前窗口/2，然后用拥塞避免算法。作用:使TCP的性能有明显的改进。</p><p>⑤乘法减小: 只要出现超时或3个重复的确认时，就要把门限值设置为当前拥塞值的一半，并大大减小拥塞窗口的数值</p><p>⑥加法增大：在拥塞阶段,拥塞窗口按线性规律增大</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zshuhan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zshuhan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建免费个人博客</title>
    <link href="https://zshuhan.github.io/2020/04/22/hexo+github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zshuhan.github.io/2020/04/22/hexo+github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-04-21T16:28:34.274Z</published>
    <updated>2020-04-21T17:00:58.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>欢迎来访！！</p></blockquote><h3 id="1环境说明"><a class="markdownIt-Anchor" href="#1环境说明"></a> 1.环境说明</h3><ol><li>Windows</li><li>node.js</li><li>git</li><li>hexo</li></ol><h3 id="2-搭建github"><a class="markdownIt-Anchor" href="#2-搭建github"></a> 2. 搭建github</h3><p>前提：要有一个github账号（没有的话去注册一个）</p><ol><li>创建仓库<br />在GitHub.com中右上角，点击加号，有个New repository，新建仓库。<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200421232716510.png#pic_center"  alt="在这里插入图片描述" /><br />新建一个名为你的用户名.github.io的仓库（一定要是你的用户名），点击create repository（我这里是已经建过了）这样就完成啦！<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000216991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTExNQ==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述" /></li></ol><h3 id="3安装"><a class="markdownIt-Anchor" href="#3安装"></a> 3.安装</h3><h4 id="31-安装git"><a class="markdownIt-Anchor" href="#31-安装git"></a> 3.1 安装git</h4><p>进入Git官网下载<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git</a><br />安装好后，进入Git Bash，用git --version 来查看一下版本<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000244938.png"  alt="在这里插入图片描述" /><br />####3.2 安装nodejs<br />官网下载安装<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs</a><br />安装好后，打开git bash命令行，查看是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h4 id="33安装hexo"><a class="markdownIt-Anchor" href="#33安装hexo"></a> 3.3安装hexo</h4><p>以上所有都安装完成之后再安装Hexo。依旧打开git bash 输入命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>接着输入 hexo -v 查看版本<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000315571.png"  alt="在这里插入图片描述" /></p><p>到此为止，需要的东西都安装完了</p><h4 id="34初始化hexo"><a class="markdownIt-Anchor" href="#34初始化hexo"></a> 3.4初始化hexo</h4><p>创建一个文件夹名为blog（随便吧），然后在这个文件夹下直接右键git bash打开，输入hexo init</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，目录结构图：<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000332832.png"  alt="在这里插入图片描述" /></p><p>目录说明：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的静态页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：存放主题</li><li>_config.yml: 博客的配置文件</li></ul><p>初始化完成后，会有一个默认主题以及一个hello-word的默认文章。所以我们先打开看看效果，运行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>然后打开浏览器，输入 localhost:4000 就可以浏览我们的博客<br />大概这个样子？<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000418678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTExNQ==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述" /></p><p>ctrl+c可以把服务关掉</p><h3 id="4上传到github"><a class="markdownIt-Anchor" href="#4上传到github"></a> 4.上传到github</h3><h4 id="配置ssh-key"><a class="markdownIt-Anchor" href="#配置ssh-key"></a> 配置SSH key</h4><p>在git bash中，输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"username"</span></span><br><span class="line">$ git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>这里的username输入你自己的GitHub用户名，youremail输入你GitHub的邮箱。</p><p>接着连接公钥</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>然后连续3次回车，最后会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，用记事本打开并复制里面的内容<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000358965.png"  alt="" /></p><p>打开你的github主页，点击头像，进入setting <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000457613.png"  alt="在这里插入图片描述" /></p><p>点击SSH and GPG keys<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020042200052294.png"  alt="在这里插入图片描述" /><br />点击右上角的 New SSH key，进入这里<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000538689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTExNQ==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述" /></p><p>回到git bash中，测试是否成功<br />输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>以上配置好后，将hexo和GitHub关联起来，打开站点配置文件 _config.yml，找到最后deploy的部分：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>YourgithubName就是你的GitHub名字</p><p>接着打开git bash安装deploy-git部署命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br><span class="line">或者 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>hexo clean清除了你之前生成的东西,可以不加。<br />hexo g 生成静态文章，是hexo generate的缩写<br />hexo d 部署文章，是hexo deploy缩写</p><p>部署完成后，可以在浏览器中输入http://yourname.github.io 就能够访问了你的博客</p><p>你可以设置个人域名（因为我太穷了，你们自行去百度看看吧）</p><h3 id="5hexo的配置"><a class="markdownIt-Anchor" href="#5hexo的配置"></a> 5.hexo的配置</h3><p>1.基本配置<br />打开文件根目录下的_config.yml，对整个hexo架构进行配置<br />网站：<br />（我哭！那是语言！不是语音！！）<img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000646579.png"  alt="在这里插入图片描述" /><br />网址：<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000702887.png"  alt="在这里插入图片描述" /><br />主题：<br />修改主题的位置<img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422000718805.png"  alt="在这里插入图片描述" /><br />theme就是给你的博客选什么主题，从在theme这个文件夹下选，官网上<a href="https://hexo.io/themes/" target="_blank" rel="noopener">【进入】</a>有很多个主题，默认安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。</p><p>我用的主题是butterfly，可以去作者的博客康康，里面有详细的配置。<a href="https://jerryc.me/" target="_blank" rel="noopener">作者</a></p><p>2.新增导航栏选项<br />git bash中执行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><p>它就会在根目录下source文件夹中新建了一个tags文件夹，里面包含index.md文件，在index.md中写上你想要在网站上展示出来的东西。</p><h3 id="6最后"><a class="markdownIt-Anchor" href="#6最后"></a> 6.最后</h3><p>博客到这里就差不多做完啦！再想完善完善的话，多多去康康其他博主的博客叭！扎油！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="博客" scheme="https://zshuhan.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://zshuhan.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（二）之应用层</title>
    <link href="https://zshuhan.github.io/2020/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://zshuhan.github.io/2020/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-04-17T14:38:36.368Z</published>
    <updated>2020-04-17T14:47:07.269Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h2><h3 id="网络应用的体系结构"><a class="markdownIt-Anchor" href="#网络应用的体系结构"></a> 网络应用的体系结构</h3><h4 id="客户机服务器结构"><a class="markdownIt-Anchor" href="#客户机服务器结构"></a> 客户机/服务器结构</h4><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020041321341296.png#pic_center"  alt="在这里插入图片描述" /><br /><em><strong>服务器;</strong></em></p><ol><li>7*24小时提供服务</li><li>永久性访问地址</li><li>利用大量服务器实现可拓展性</li></ol><p><em><strong>客户机：</strong></em></p><ol><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可能使用动态IP地址</li><li>不会与其他客户机直接通信</li></ol><h4 id="p2p结构"><a class="markdownIt-Anchor" href="#p2p结构"></a> P2P结构</h4><ul><li>没有永远在线的服务器</li><li>任意端系统/节点之间可以直接通讯</li><li>节点间歇性接入网络</li><li>节点可能改变IP地址</li></ul><blockquote><p>优点：高度可伸缩 <br />缺点：难于管理</p></blockquote><h4 id="混合结构"><a class="markdownIt-Anchor" href="#混合结构"></a> 混合结构</h4><ul><li>文件传输使用P2P结构</li><li>文件的搜索采用C/S结构—集中式</li></ul><h3 id="网络应用进程通信"><a class="markdownIt-Anchor" href="#网络应用进程通信"></a> 网络应用进程通信</h3><h4 id="进程主机上运行的应用程序"><a class="markdownIt-Anchor" href="#进程主机上运行的应用程序"></a> 进程：主机上运行的应用程序</h4><ul><li><p>同一主机上进程的通信：采用进程间通信机制，由操作系统提供</p></li><li><p>不同主机上进程的通信：消息交换</p></li><li><p>客户机进程：发起通信的进程（发送请求初始化通信）</p></li><li><p>服务器进程：等待通信的进程（等待来自客户的请求）</p></li></ul><h4 id="套接字socketip地址端口号"><a class="markdownIt-Anchor" href="#套接字socketip地址端口号"></a> 套接字：socket=IP地址+端口号</h4><pre><code>套接字是提供应用程序创建和使用的数据结构在应用层，客户进程和服务器进程间的通信是两个套接字间的通信</code></pre><p>①套接字地址（通信时需要）</p><ul><li>本地套接字地址+远程套接字地址 （一对套接字地址标识）<br />定义套接字地址：用TCP/IP协议族的标识符定义</li></ul><p>②寻找套接字地址</p><ul><li>服务器站点：<ul><li>本地套接字地址：由操作系统提供</li><li>远程套接字地址：建立连接的客户套接字地址</li></ul></li><li>客户站点：<ul><li>本地套接字地址：由操作系统提供</li><li>远程套接字地址：知道端口号和IP地址<br />知端口号，不知IP地址</li></ul></li></ul><h3 id="网络应用的需求与传输层服务"><a class="markdownIt-Anchor" href="#网络应用的需求与传输层服务"></a> 网络应用的需求与传输层服务</h3><h4 id="网络应用对传输服务的需求"><a class="markdownIt-Anchor" href="#网络应用对传输服务的需求"></a> 网络应用对传输服务的需求</h4><ul><li>可靠性、带宽、时延</li></ul><h4 id="使用的传输服务"><a class="markdownIt-Anchor" href="#使用的传输服务"></a> 使用的传输服务</h4><p><em><strong>①TCP服务:</strong></em></p><ul><li>面向连接：C/S进程间需要建立连接</li><li>流量控制：发送方不会发送速度过快超过接收方的处理能力</li><li>拥塞控制：当网络负载过重时能够限制发送方的发送速度</li><li>不提供最小带保障</li></ul><p><strong>②UDP服务:</strong></p><ul><li>无连接</li><li>不可靠的数据传输</li><li>不提供可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障</li></ul><h3 id="web应用"><a class="markdownIt-Anchor" href="#web应用"></a> WEB应用</h3><h4 id="万维网www"><a class="markdownIt-Anchor" href="#万维网www"></a> 万维网（WWW）</h4><pre><code>由多个网页互相连接，以客户机/服务器的方式工作</code></pre><h4 id="统一资源定位符url"><a class="markdownIt-Anchor" href="#统一资源定位符url"></a> 统一资源定位符URL</h4><ul><li>一般形式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;<br />协议包括ftp、http、News<br />主机是存放资源的主机在互联网的域名</li></ul><h4 id="http协议"><a class="markdownIt-Anchor" href="#http协议"></a> HTTP协议</h4><pre><code>超文本传输协议：采用C/S结构，使用TCP传输服务，端口号80</code></pre><h5 id="主要特点"><a class="markdownIt-Anchor" href="#主要特点"></a> 主要特点：</h5><p>面向事务的客户服务器协议<br />无状态：服务器不维护任何有关客户端过去所发请求的信息<br />无连接</p><h5 id="两类消息"><a class="markdownIt-Anchor" href="#两类消息"></a> 两类消息</h5><h6 id="a请求消息"><a class="markdownIt-Anchor" href="#a请求消息"></a> a)请求消息</h6><p>①从客户向服务器发送报文<br />②通用格式（如图）<br />③上传输入方法：</p><ul><li>POST方法：在请求消息的消息体中上传客户的输入</li><li>URL方法：（使用GET方法）输入信息通过request行的URL字段上传</li></ul><p>④方法类型：</p><ul><li>i.HTTP/1.0 非持久性连接：GET、POST、HEAD</li><li>ii.HTTP/1.1 持久性连接：GET、POST、HEAD、PUT、DELETE</li></ul><h6 id="b响应消息"><a class="markdownIt-Anchor" href="#b响应消息"></a> b)响应消息</h6><p>①从服务器到客户的回答<br />②格式（如图）<br />③HTTP响应状态码：</p><ul><li>1xx表示通知信息</li><li>2xx表示成功</li><li>3xx表示重定向</li><li>4xx表示客户端的差错</li><li>5xx表示服务器的差错</li></ul><h5 id="请求一个万维网文档所需的时间"><a class="markdownIt-Anchor" href="#请求一个万维网文档所需的时间"></a> 请求一个万维网文档所需的时间</h5><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200413213025685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTExNQ==,size_16,color_FFFFFF,t_70#pic_center"  alt="在这里插入图片描述" /><br />TotalTime=2RTT+传输文档的时间</p><h5 id="持续连接和非持续连接"><a class="markdownIt-Anchor" href="#持续连接和非持续连接"></a> 持续连接和非持续连接</h5><h6 id="持续连接"><a class="markdownIt-Anchor" href="#持续连接"></a> 持续连接：</h6><ol><li>每个TCP连接允许传输多个对象</li><li>两种工作方式<br />①流水线方式：客户持续发出请求。<br />②非流水线方式：客户只有收到个响应后才能发出下一个请求</li></ol><h6 id="非持续连接"><a class="markdownIt-Anchor" href="#非持续连接"></a> 非持续连接：</h6><pre><code>每个TCP连接最多允许传输一个对象。每个对象需2RTT</code></pre><h5 id="http过程"><a class="markdownIt-Anchor" href="#http过程"></a> HTTP过程</h5><p>(1) URL为http：<a href="//www.abc.com" target="_blank" rel="noopener">//www.abc.com</a>,浏览器分析URL，使用HTTP协议解析。<br />(2) 浏览器向 DNS 请求解析 <a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a> 的 IP 地址，得到其IP地址。<br />(3)浏览器与服务器建立 TCP 连接，目标端口默认80，发送请求GET。<br />(4) 服务器给出响应，把文件 index.htm 发给浏览器。<br />(5) TCP 连接释放。<br />(6) 浏览器将收到的index.html使用html解释并显示给用户。</p><h3 id="email应用"><a class="markdownIt-Anchor" href="#email应用"></a> Email应用</h3><h4 id="组成结构"><a class="markdownIt-Anchor" href="#组成结构"></a> 组成结构</h4><h5 id="用户代理"><a class="markdownIt-Anchor" href="#用户代理"></a> 用户代理</h5><ul><li>用户与电子邮件系统的接口</li><li>四个功能：撰写、显示、处理、通信</li></ul><h5 id="邮件服务器"><a class="markdownIt-Anchor" href="#邮件服务器"></a> 邮件服务器</h5><pre><code>使用CS模型、用来发送和接收邮件</code></pre><h5 id="邮件发送协议smtp和邮件读写协议pop3-imap"><a class="markdownIt-Anchor" href="#邮件发送协议smtp和邮件读写协议pop3-imap"></a> 邮件发送协议（SMTP）和邮件读写协议（POP3、IMAP）</h5><p><strong>①SMTP协议（简单邮件传输协议）</strong></p><ul><li>使用TCP进行email消息的可靠传输</li><li>端口号25</li><li>使用CS模型</li><li>SMTP通信的三个阶段：<br />i.建立连接<br />ii.邮件传送<br />iii.连接释放</li></ul><p><strong>②POP3协议</strong></p><ul><li>使用PULL的方式取出邮件，模型CS，使用TCP传输，端口110</li><li>客户要运行POP客户程序，服务端要运行POP服务程序</li><li>无状态</li><li>特点：只要用户从POP服务端读取了邮件，POP服务器就把该邮件删除</li><li>两种工作模式：下载并保留和下载并删除</li></ul><p><strong>③IMAP协议</strong>：所有消息统一保留在服务器</p><h4 id="电子邮件的信息格式"><a class="markdownIt-Anchor" href="#电子邮件的信息格式"></a> 电子邮件的信息格式</h4><p>首部+主体</p><ul><li>首部：发件人、收件人和标题</li><li>主体：消息本身（只能是ASCII字符）</li></ul><h4 id="mime通用互联网邮件扩充"><a class="markdownIt-Anchor" href="#mime通用互联网邮件扩充"></a> MIME（通用互联网邮件扩充）</h4><ul><li>通过在邮件头部增加额外的行以声明MIME的内容类型</li><li>出现原因：SMTP只能发送英文ASCII，不能发送汉字、图片</li></ul><h3 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h3><h4 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h4><ul><li>使用CS模型，运行在UDP上，端口号53</li><li>多层命名服务器构成的分布式数据库</li></ul><h4 id="域名结构"><a class="markdownIt-Anchor" href="#域名结构"></a> 域名结构：</h4><ul><li>….三级域名.二级域名.顶级域名<br />如：<a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a><br />顶级域名有cn，com，net，gov</li></ul><h4 id="域名服务器"><a class="markdownIt-Anchor" href="#域名服务器"></a> 域名服务器</h4><ul><li><p>分布式DNS系统，以层次方式组织，负责域名-&gt;IP解析</p></li><li><p>类型：（四种）<br />①根域名服务器</p><ul><li>本地域名解析服务器法解析域名时，访问根域名服务器</li><li>管理顶级域名，并不直接解析成IP，而是指向下一步查询哪个顶级域名服务器</li></ul><p>②顶级域名服务器（TLD）</p><ul><li>负责com，org，net，edu等顶级域名和国家顶级域名</li><li>管理所有注册的二级域名</li></ul><p>③权威域名服务器</p><ul><li>组织的域名解析服务器，提供组织内部服务器的解析服务</li></ul><p>④主机域名服务器</p><ul><li>主机发出DNS请求时，就发给本地域名服务器</li></ul></li></ul><h4 id="域名解析过程"><a class="markdownIt-Anchor" href="#域名解析过程"></a> 域名解析过程</h4><pre><code>- 域名到IP称为正向解析，IP到域名称为反向解析- 过程：主机向本地域名服务器的查询一般都是采用递归查询。如果查到，则直接返回IP。本地域名服务器无法解析，则本地域名服务器向根域名服务器的查询通常是采用迭代查询，根域名服务器返回顶级域名地址，然后本地服务器向顶级域名服务器查询。顶级服务器若不能解析，则给出权威域名服务器地址，本地域名服务器向权威域名服务器查询。若查到，则缓存后返回给主机；还查不到，则返回域名解析失败</code></pre><h3 id="ftp文件传输协议"><a class="markdownIt-Anchor" href="#ftp文件传输协议"></a> FTP（文件传输协议）</h3><pre><code>提供交互的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</code></pre><h4 id="ftp的工作原理"><a class="markdownIt-Anchor" href="#ftp的工作原理"></a> FTP的工作原理</h4><ul><li>使用CS模型，使用TCP传输。FTP服务器有一个主进程负责新请求，若干从进程负责单个请求</li><li>服务器打开端口21，监听并等待客户连接</li><li>有连接请求后，启动从进程处理连接，然后主进程继续监听</li><li>主进程必须在会话期间保存用户状态，记录用户在远程目录上的当前位置</li></ul><h4 id="ftp的特点"><a class="markdownIt-Anchor" href="#ftp的特点"></a> FTP的特点</h4><ul><li>只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务</li><li>减少或消除在不同操作系统下处理文件的不兼容性</li><li>使用客户服务器方式</li></ul><h4 id="ftp的两个连接tcp连接"><a class="markdownIt-Anchor" href="#ftp的两个连接tcp连接"></a> FTP的两个连接（TCP连接）</h4><p>①控制连接</p><ul><li>端口号21，用来传输连接请求等待控制信息，不能用来传输文件。在文件传输过程中一直处于打开状态，方便及时终止传输</li></ul><p>②数据连接</p><ul><li>端口号20，用来连接客户端和服务端的数据传输进程，传输完毕后该连接关闭</li><li>若要修改服务器上的文件，则先下载下来，修改，再上传上去；若要修改大文件需要全部复制下来</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zshuhan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zshuhan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络学习笔记（一）</title>
    <link href="https://zshuhan.github.io/2020/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://zshuhan.github.io/2020/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-04-17T08:19:48.650Z</published>
    <updated>2020-04-17T08:36:55.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>正在学习计算机网络，为了方便日后回忆，在此记录自己的学习笔记。</p></blockquote><h1 id="一-计算机网络概述"><a class="markdownIt-Anchor" href="#一-计算机网络概述"></a> 一、计算机网络概述</h1><p>先放上思维导图！方便记忆<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200305113359935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTExNQ==,size_16,color_FFFFFF,t_70"  alt="概述思维导图" /></p><h2 id="1互联网"><a class="markdownIt-Anchor" href="#1互联网"></a> 1.互联网</h2><h3 id="11网络的网络"><a class="markdownIt-Anchor" href="#11网络的网络"></a> 1.1网络的网络</h3><ul><li>计算机网络：结点+链路</li><li>互连网：通过路由器把网络互连起来，构成计算机网络</li><li>互联网：特指Internet，是全球最大的、开放的、采用通用协议进行众多网络相连的特定计算机网络。特点：连通性和共享</li><li>主机：与网络相连的计算机</li></ul><h3 id="12互联网基础结构发展的三个阶段"><a class="markdownIt-Anchor" href="#12互联网基础结构发展的三个阶段"></a> 1.2互联网基础结构发展的三个阶段</h3><ul><li>第一阶段：从单个网络ARPANET向互联网发展得过程</li><li>第二阶段：建成三级结构的互联网</li><li>第三阶段：逐渐形成了多层次ISP结构的互联网<br /><em>ISP</em>： 互联网服务提供商</li></ul><h3 id="13互联网的组成"><a class="markdownIt-Anchor" href="#13互联网的组成"></a> 1.3互联网的组成</h3><pre><code> 边缘部分+核心部分</code></pre><p>1.边缘部分</p><ul><li>由所有连接在互联网上的主机（端系统）组成<ul><li>端系统之间的通信：主机A的某个进程与主机B的另一个进程进行通信</li><li>两种通信方式：<br />（1）客户端/服务端方式（C/S方式）：进程之间的服务与被服务<br />（2）对等方式（P2P方式）：不区分服务与被服务关系</li></ul></li><li>用户直接使用来进行通信和资源共享</li></ul><p>2.核心部分</p><ul><li>重要工作者：路由器<ul><li>路由器：实现<strong>分组交换</strong>，<strong>转发</strong>收到的分组</li></ul></li></ul><blockquote><p>疑问：什么是分组交换？</p></blockquote><p>数据交换是实现数据通过网络核心从源主机到另一个主机!</p><p>1.为什么需要数据交换？</p><ul><li>1).链路问题  2).连通性 3).网络规模</li></ul><p>2.什么是交换？</p><ul><li>动态转接——把一条电话线转接到另一条电话线，使之连通</li><li>动态分配传输路线的资源</li></ul><p>3.数据交换的类型<br /><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200305152249170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTExNQ==,size_16,color_FFFFFF,t_70"  alt="数据交换类型" /></p><p><mark>注：计算机交换方式绝大多数是分组交换，极少数是电路交换，绝不可能是报文交换</mark></p><h3 id="14计算机网络的类别"><a class="markdownIt-Anchor" href="#14计算机网络的类别"></a> 1.4计算机网络的类别</h3><ol><li>按网络作用范围：<br />广域网、 城域网、局域网、个人区域网</li><li>按网络的使用者：<br />公用网 、专用网</li><li>用来把用户接入互联网的网络</li></ol><h3 id="15计算机性能"><a class="markdownIt-Anchor" href="#15计算机性能"></a> 1.5计算机性能</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200305170531519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTExNQ==,size_16,color_FFFFFF,t_70"  alt="计算机网络的性能" /></p><ol><li>速率：数据的传送速度（单位：bit/s）</li><li>带宽：在单位时间内网络中的某信道所能通过的“<strong>最高数据率</strong>”</li><li>吞吐量：在单位时间内通过某个网络的数据量</li><li>时延：数据从网络的一端传送到另一端所需的时间<br />包括：<br />1） 发送时延<br />2）传播时延<br />3）处理时延<br />4）排队时延<br />总时延=发送时延+传播时延+处理时延+排队时延</li><li>时延带宽积：传播时延 x 带宽</li><li>往返时间RTT：从发送方到接收方总共经历的时间</li><li>利用率：分为信道利用率和网络利用率</li></ol><h3 id="16计算机网络的体系结构"><a class="markdownIt-Anchor" href="#16计算机网络的体系结构"></a> 1.6计算机网络的体系结构</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020031719475649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTExNQ==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述" /><br /><mark><strong>体系结构=层+协议</strong></mark>（协议是水平的、服务是垂直的）<br />网络协议：为进行网络的数据交换而建立的规则（标准或约定）</p><ul><li>协议三要素：语法、语义、同步<br />（1）语法：数据与控制信息的结构或格式 。<br />（2）语义：需要发出何种控制信息，完成何种动作以及做出何种响应。<br />（3）同步：事件实现顺序的详细说明。</li></ul><h6 id="1osi的体系结构"><a class="markdownIt-Anchor" href="#1osi的体系结构"></a> 1.OSI的体系结构：</h6><p>（1). 应用层：实现用户的应用程序自之间的通信过程控制<br />（2). 表示层：对数据进行格式变换、加密解密和压缩恢复<br />（3). 会话层：建立、管理和终止会话，以及数据交换<br />（4). 运输层：提供可靠的端-端的数据传输服务<br />（5). 网络层：通过路由选择算法为分组通过通信子网选择适当的传输路径<br />（6). 数据链路层：在物理层提供比特流的基础上，采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路<br />（7). 物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输</p><h5 id="2tcpip的四层协议应用层-运输层-网际层ip-网络接口层"><a class="markdownIt-Anchor" href="#2tcpip的四层协议应用层-运输层-网际层ip-网络接口层"></a> 2.TCP/IP的四层协议：应用层、运输层、网际层IP、网络接口层</h5><h5 id="3-计算机网络综合osi和tcpip的优点采用五层协议的体系结构"><a class="markdownIt-Anchor" href="#3-计算机网络综合osi和tcpip的优点采用五层协议的体系结构"></a> 3. <mark>计算机网络</mark>综合OSI和TCP/IP的优点，采用<mark>五层协议的体系结构</mark></h5><p>（1).应用层 ：该层是体系结构的最高层，直接为用户的应用进程提供服务<br />（2). 运输层：负责向两台主机中进程之间的通信提供通用的数据传输服务。主要使用的两种协议：<br />①传输控制协议（TCP）：提供面向连接的，可靠的数据传输服务（数据传输的单位是报文段）<br />②用户数据报协议（UDP）：提供无连接的，尽最大努力的数据传输服务（数据传输的单位是用户数据报)<br />（3). 网络层：负责为分组交换网上的不同主机提供通信服务。使用IP协议<br />（4). 数据链路层：在两个相邻结点之间传送数据时，数据链路层将网络层提供的IP数据组装成帧，在两个相邻结点间的链路上“透明”地传送帧中的数据<br />（5). 物理层：透明地传送比特流（数据单位是比特）</p><h5 id="4实体-协议-服务和服务访问点"><a class="markdownIt-Anchor" href="#4实体-协议-服务和服务访问点"></a> 4.实体、协议、服务和服务访问点</h5><p>1.实体: 表示任何可发送或接收信息的硬件或软件进程。<br />2.协议: 控制两个对等实体进行通信的规则的集合<br />3.服务：在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务<br />4.服务访问点：在同一系统中相邻两层的实体进行交互</p><p><strong>问题：</strong></p><blockquote><p>Q1：协议与服务的区别与联系<br />答：1）区别：<br />①协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。<br />②协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。 2）联系：<br />①在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。 ②要实现本层协议，还需要使用下层所提供的服务</p></blockquote><blockquote><p>Q2：TCP/IP与OSI的系统结构进行比较，讨论其异同之处<br />答：1）OSI和TCP/IP的相同点是二者均采用层次结构，而且都是按功能分层。<br />2）OSI和TCP/IP的不同点：<br />①OSI分七层，自下而上分为物理层、数据链路层、网络层、运输层、会话层、表示层和应用层，而TCP/IP分四层：网络接口层、网间网层（IP）、传输层（TCP） 和应用层。<br />②OSI层次间存在严格的调用关系，两个（N）层实体的通信必须通过下一层（N-1）层实体，不能越级，而TCP/IP可以越过紧邻的下一层直接使用更低层次所提供的服务，因而减少了一些不必要的开销，提高了协议的效率<br />③OSI只考虑用一种标准的公用数据网，TCP/IP更侧重于异构网的互联问题</p></blockquote><blockquote><p>Q3：3.如何理解“透明”？<br />答：透明表示某个实际存在的事物看起来却好像不存在一样。比如你电脑上的应用程序，用户只需知道特定的按钮的功能，并不需要知道按钮的功能是怎么实现的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://zshuhan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://zshuhan.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zshuhan.github.io/2020/04/17/hello-world/"/>
    <id>https://zshuhan.github.io/2020/04/17/hello-world/</id>
    <published>2020-04-17T05:02:25.987Z</published>
    <updated>2020-04-17T05:02:25.987Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
